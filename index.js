// Generated by CoffeeScript 2.3.1
(function() {
  // Legacy parser
  // -------------

  // This is the legacy parser for flat-ornament. It supports ornaments stored as a data structure, including where parts of the data structure are replaced by strings, which are parsed using the simple language defined in `language.jison`, which was meant to generate content identical to the data structure. (This was originally meant to allow tools to go back-and-forth between the data structure and the textual representations.)
  var ID, NOT, NOTHING, Parser, compile, compile_ornament, compile_statement, parser, run;

  ({name: this.name} = require('./package'));

  ({Parser} = require('./language'));

  NOTHING = function() {};

  NOT = function(x) {
    return !x;
  };

  ID = function(x) {
    return x;
  };

  parser = function(commands) {
    var p;
    p = new Parser();
    p.yy.op = commands;
    return p;
  };

  compile = function(ornaments, commands, parser) {
    var structure;
    switch (false) {
      case typeof ornaments !== 'string':
        return parser.parse(`ornaments ${ornaments}`);
      case ornaments.length == null:
        structure = ornaments.map(function(ornament) {
          return compile_ornament(ornament, commands, parser);
        });
        return async function() {
          var i, len, ornament;
          for (i = 0, len = structure.length; i < len; i++) {
            ornament = structure[i];
            if ((await ornament.call(this))) {
              return;
            }
          }
        };
      default:
        return NOTHING;
    }
  };

  // Each ornament is a list of statements which are executed in order.

  // A statement consists of:
  // - a `type` (the command to be executed);
  // - optional `param` or `params[]` (parameters for the command);
  // - optional `not` (to reverse the outcome).
  // Execution continues as long as the outcome of a statement is true.

  // Normally conditions are listed first, while actions are listed last, but really we don't care.

  // Applying `not` to an action probably won't do what you expect.

  // Return true if a command returned `over`, indicating the remaining ornaments in the list should be skipped.
  compile_ornament = function(ornament, commands, parser) {
    var structure;
    switch (false) {
      case typeof ornament !== 'string':
        return parser.parse(`ornament ${ornament}`);
      case ornament.length == null:
        structure = ornament.map(function(statement) {
          return compile_statement(statement, commands, parser);
        });
        return async function() {          // This function return `true` if the execution should stop.
          var i, len, statement, truth;
          for (i = 0, len = structure.length; i < len; i++) {
            statement = structure[i];
            truth = (await statement.call(this));
            if (truth === 'over') {
              return true;
            }
            if (!truth) {
              // Terminate the ornament and continue to the next one, if any condition or action returned false.
              return false;
            }
          }
          // If no precondition / postcondition / action returned false, continue to the next ornament.
          return false;
        };
      default:
        return NOTHING;
    }
  };

  compile_statement = function(statement, commands, parser) {
    var c, params, truthy, type;
    switch (false) {
      // String statement
      // A statement might be a `{type,param?,params?,not?}` object, or a `[('not',)type,params...]` array, or a `"(not )type( param param â€¦)"` string.
      // All statements are converted to `{type,param?,params?,not}` for evaluation.
      case typeof statement !== 'string':
        return parser.parse(`statement ${statement}`);
      // Array statement
      case statement.length == null:
        params = statement.slice(0);
        if (params[0] === 'not') {
          params.shift();
          truthy = NOT;
        } else {
          truthy = ID;
        }
        type = params.shift();
        if (type == null) {
          return NOTHING;
        }
        c = commands[type];
        if (c == null) {
          return NOTHING;
        }
        return async function() {
          return truthy((await c.apply(this, params)));
        };
      default:
        // Object statement
        ({type} = statement);
        if (type == null) {
          return NOTHING;
        }
        c = commands[type];
        if (c == null) {
          return NOTHING;
        }
        truthy = statement.not ? NOT : ID;
        switch (false) {
          case statement.params == null:
            return async function() {
              return truthy((await c.apply(this, statement.params)));
            };
          case statement.param == null:
            return async function() {
              return truthy((await c.call(this, statement.param)));
            };
          default:
            return async function() {
              return truthy((await c.call(this)));
            };
        }
    }
  };

  run = function(ornaments, commands) {
    return (compile(ornaments, commands, parser(commands))).call(this);
  };

  module.exports = {run, parser, compile};

}).call(this);
